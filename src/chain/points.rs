use std::collections::HashMap;

use rand::{thread_rng, Rng};
use serenity::{
    model::id::{GuildId, UserId},
    prelude::TypeMap,
};

use crate::{
    database::{increase_points, tables::leaderboards::increase_server_points},
    DatabaseConn,
};

use super::Chain;

/// Calculates the total amount of points generated by a chain
///
/// Calculated by the formula:
/// ```text
/// floor(random(15,17.5)*(length^(1/3))*(users^(1/3)) * 1.2)
/// ```
fn points(len: u16, users: u64) -> u64 {
    (thread_rng().gen_range(15.0 .. 17.5)
        * (len as f32).powf(1.0 / 3.0)
        * (users as f32).powf(1.0 / 3.0)
        * 1.2)
        .floor() as u64
}

/// Calculates the percentage of the chain each user contributed
fn user_percent(len: u64, user_messages: HashMap<UserId, u16>) -> HashMap<UserId, f32> {
    let mut percentages = HashMap::new();

    for (user, num_messages) in user_messages {
        let percent = (num_messages as f32) / (len as f32);
        percentages.insert(user, -percent.powi(2) + 2.0 * percent);
    }

    percentages
}

/// Calculates the number of points that should be given to each user
///
/// If the chain is a single person then there are no points provided
pub fn points_per_user(chain: &Chain, breaker: UserId) -> HashMap<UserId, u64> {
    let mut users = chain.chainers.clone();
    let mut user_messages = chain.num_messages.clone();
    let breaker_msgs;

    // remove the breaker from the chain users
    if users.contains(&breaker) {
        users.remove(users.iter().position(|u| u == &breaker).unwrap());
        breaker_msgs = user_messages.remove(&breaker).unwrap();
    } else {
        breaker_msgs = 0;
    }

    // Get the percent of the chain each user contributed
    let user_percent = user_percent((chain.length - breaker_msgs) as u64, user_messages);

    // Count number of users with more than 1/users of the messages
    let mut active_users = 0;

    for (_, percent) in &user_percent {
        if *percent >= 1.0 / (chain.chainers.len() + 1) as f32 {
            active_users += 1;
        }
    }

    let total_points = points(chain.length, active_users);

    // Give breaker 25% of total points and split everyone else's points propotionally
    let mut user_points = HashMap::new();
    user_points.insert(breaker, (total_points as f32 * 0.25).floor() as u64);
    let total_points = total_points as f32 * 0.75;

    for (user, percent) in user_percent {
        user_points.insert(user, (total_points * percent).floor() as u64);
    }

    user_points
}

/// Stores players new points in the database
pub async fn give_points(points: &HashMap<UserId, u64>, data: &TypeMap, server_id: GuildId) {
    let database = data.get::<DatabaseConn>().unwrap().lock().await;

    for (user, points) in points {
        increase_points(&database, *user, *points);
        increase_server_points(&database, server_id, *user, *points);
    }
}
